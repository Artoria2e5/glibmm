#! @PERL@
#
# @configure_input@
#
######################################################################
# gmmproc (version 4)
######################################################################
#
# *** WARNING: Only modify gmmproc.in. gmmproc is built. ***
#
# Copyright 2001, Karl Einar Nelson, Murray Cumming
# Copyright 2011, Krzesimir Nowak
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
#
# 'classes':
# WrapParser: steps through .hg and .ccg files, outputting appropriate m4 code with Outputter.
# Outputter: Used by WrapParser to ouput wrapper code. Ouputs *.g1 temp file and uses m4 to generate *.g2 from it. Then outputs .h and .cc files.
# Function: Contains information about C and C++ functions and signals.
#
######################################################################

########################## 'main()' ##################################

$main::procdir;
$main::m4path;

#BEGIN {
#  # get prefix info from configure
#  my $prefix = "@prefix@";
#  my $exec_prefix = "@exec_prefix@";
#  my $libdir = "@libdir@";

#  # This line must match the install directory
#  $main::procdir = $libdir . '/@GLIBMM_MODULE_NAME@/proc';
#  $main::m4path = "@M4@";

#  push(@INC, $main::procdir . '/pm');
#}

my $g_prefix = '@prefix@';
my $g_exec_prefix = '@exec_prefix@';
my $g_libdir = '@libdir@';
my $g_procdir = $g_libdir . '/@GLIBMM_MODULE_NAME@/proc';
my $g_m4path = '@M4@';

push (@INC, $g_procdir . '/pm');

use strict;
use warnings;
use GetOpt::Long qw(:config permute)

require Output;
require WrapParser;

# initialize globals
@main::macrodirs = ();
$main::srcdir    = '.';
$main::defsdir   = '.';
$main::source    = '';
$main::unwrapped = 1;
$main::debug     = (exists $ENV{'GMMPROC_DEBUG'}) ? $ENV{'GMMPROC_DEBUG'} : '';

my $glob_templates_a_r = [];

# prototypes
sub parse_command_line_args();
sub print_help ();
sub process_list_file ($);
sub print_help ($);
sub add_file_to_list ($);
sub main ();

main ();

#main()
parse_command_line_args();

my $objOutputter = &Output::new($main::m4path, \@main::macrodirs);
my $objWrapParser = &WrapParser::new($objOutputter);

$$objWrapParser{srcdir} = $main::srcdir;
$$objWrapParser{defsdir} = $main::defsdir;
$$objWrapParser{source} = $main::source;
$$objOutputter{source} = $main::source;
$$objOutputter{destdir} = $ARGV[1];

# Merge the C docs, e.g. gtk_docs.xml

# Suck the whole file into one big string, breaking it into tokens:
$objWrapParser->read_file($main::srcdir, $main::source);

# Parse output
$objWrapParser->parse_and_build_output();

# Write out *.g1 temporary file:
$objOutputter->output_temp_g1($$objWrapParser{module}); # e.g. "gtk"

# Execute m4 to get *.g2 file:
{
  my $exitcode = $objOutputter->make_g2_from_g1();
  if ($exitcode)
  {
    $objOutputter->remove_temp_files() unless ($main::debug);

    print STDERR "m4 failed with exit code $exitcode.  Aborting...\n";
    exit($exitcode);
  }
}

# Section out the resulting output
$objOutputter->write_sections_to_files();
$objOutputter->remove_temp_files() unless ($main::debug);

#Warn about any unwrapped function/signals:
if ($main::unwrapped)
{
  my @unwrapped = GtkDefs::get_unwrapped();
  @unwrapped = grep { exists $$_{entity_type} } @unwrapped;

  if (@unwrapped)
  {
    my @methods = grep { $$_{entity_type} eq 'method' and $$_{c_name} !~ m/^_/s } @unwrapped;
    my @signals = grep { $$_{entity_type} eq 'signal' } @unwrapped;
    # Don't take non-readable construct-only properties into account.
    my @properties = grep { $$_{entity_type} eq 'property' and ( $$_{readable} or not $$_{construct_only} ) } @unwrapped;

    local $, = "\ngmmproc:   ";
    local $\ = "\n";

    if (@methods)
    {
      print STDERR ('gmmproc: Unwrapped functions:',
                    map($$_{c_name}, @methods));
    }
    if (@properties)
    {
      print STDERR ('gmmproc: Unwrapped properties:',
                    map($$_{class} . '::' . $$_{name}, @properties));
    }
    if (@signals)
    {
      print STDERR ('gmmproc: Unwrapped signals:',
                    map($$_{class} . '::' . $$_{name}, @signals));
    }
  }
}

# end of program
exit;


####################################################################


sub print_usage ()
{
  print <<EOF;
Usage: gmmproc [options] -s|--source dir -d|--destination dir
       (-l|--list file)|(name1 [name2 [name3 [name4 ...]]]

Options:
  -s dir
  --source dir         Specify source directory with template files.

  -d dir
  --destination dir    Specify destination directory for generated files.

  -l file
  --list file          Specify a file path containing list of templates
                       to process.

  -h
  --help               This usage message.

  -g
  --debug              Leave intermediate output arround for analysis.
                       Alternatively, set GMMPROC_DEBUG=1 in the environment.

  -u
  --unwrapped          Warn about possible unwrapped functions.

  -d dir
  --defs dir           Change the directory to search for defs.

  -I dir
  --include dir        Specify the directory with m4 files.

This will read template files from source directory and generate files
to destination directory:
(srcdir/template.{h,cc}g => destdir/{template.{h,cc},private/template_p.h}).

Templates files can be given as either a file containing list of files or passed
explicitly as a param or both.
EOF
}

# void parse_command_line_args()
sub parse_command_line_args()
{
  GetOptions
  print_usage() if ($#ARGV == -1);
 
  while ($#ARGV != -1)
  {
    $_ = shift @ARGV;

    if (/^-/)
    {
      print_usage() if ( /^--help/);
      print_usage() if ( /^-h/);
      if (/^-I/)
      {
        push @main::macrodirs, shift @ARGV;
      }
      elsif (/^--unwrapped/)
      {
        $main::unwrapped = 1;
      }
      elsif (/^--defs/)
      {
        $main::defsdir = shift @ARGV;
      }
      elsif (/^--debug/)
      {
        $main::debug = 1;
      }
      else
      {
        print "unknown parameter $_\n";
      }
      next;
    }

    last;
  }

  # we already have one argument

  if ($#ARGV != 1)
  {
    print STDERR ('Invalid number of arguments (', $#ARGV + 2, ")\n");
    print_usage();
  }

  $main::srcdir = $ARGV[0];
  $main::source = $_;

  push @main::macrodirs, $main::procdir . '/m4';
}

sub print_help ($)
{
  print_usage ();
  exit (0);
}

main ()
{
  my $source_dir = '\\';
  my $destination_dir = '\\';
  my $unwrapped = 0;
  my $defs = '';
  my $includes_a_r = [];
  my $debug = (exists $ENV{'GMMPROC_DEBUG'}) ? $ENV{'GMMPROC_DEBUG'} : 0;
  my $opt_parse_result = GetOptions ('help|h' => \&print_help,
                                     'source|s=s' => \$source_dir,
                                     'destination|d=s' => \$destination_dir,
                                     'list|l=s' => \&process_list_file,
                                     'unwrapped|u' => \$unwrapped,
                                     'defs|d=s' => \$defs,
                                     'include|I=s@' => \$includes_a_r,
                                     'debug|g' => \$debug,
                                     '<>' => \&add_file_to_list
                                    );

  if (not $opt_parse_result or $source_dir eq '\\' or $destination_dir eq '\\'
      or @{$glob_template_list_a_r} < 1)
  {
    print_usage ();
    exit (1);
  }
  push (@{$includes_a_r}, $g_procdir . '/m4');

  my $templates_a_r = $glob_template_list_a_r;
  my $objOutputter = &Output::new($g_m4path, $includes_a_r);
  my $objWrapParser = &WrapParser::new($objOutputter);

  $$objWrapParser{srcdir} = $main::srcdir;
  $$objWrapParser{defsdir} = $main::defsdir;
  $$objWrapParser{source} = $main::source;
  $$objOutputter{source} = $main::source;
  $$objOutputter{destdir} = $ARGV[1];

  # Merge the C docs, e.g. gtk_docs.xml

  # Suck the whole file into one big string, breaking it into tokens:
  $objWrapParser->read_file($main::srcdir, $main::source);

  # Parse output
  $objWrapParser->parse_and_build_output();

  # Write out *.g1 temporary file:
  $objOutputter->output_temp_g1($$objWrapParser{module}); # e.g. "gtk"

  # Execute m4 to get *.g2 file:
  {
    my $exitcode = $objOutputter->make_g2_from_g1();
    if ($exitcode)
    {
      $objOutputter->remove_temp_files() unless ($main::debug);

      print STDERR "m4 failed with exit code $exitcode.  Aborting...\n";
      exit($exitcode);
    }
  }

  # Section out the resulting output
  $objOutputter->write_sections_to_files();
  $objOutputter->remove_temp_files() unless ($main::debug);

  #Warn about any unwrapped function/signals:
  if ($main::unwrapped)
  {
    my @unwrapped = GtkDefs::get_unwrapped();
    @unwrapped = grep { exists $$_{entity_type} } @unwrapped;

    if (@unwrapped)
    {
      my @methods = grep { $$_{entity_type} eq 'method' and $$_{c_name} !~ m/^_/s } @unwrapped;
      my @signals = grep { $$_{entity_type} eq 'signal' } @unwrapped;
      # Don't take non-readable construct-only properties into account.
      my @properties = grep { $$_{entity_type} eq 'property' and ( $$_{readable} or not $$_{construct_only} ) } @unwrapped;

      local $, = "\ngmmproc:   ";
      local $\ = "\n";

      if (@methods)
      {
        print STDERR ('gmmproc: Unwrapped functions:',
                      map($$_{c_name}, @methods));
      }
      if (@properties)
      {
        print STDERR ('gmmproc: Unwrapped properties:',
                      map($$_{class} . '::' . $$_{name}, @properties));
      }
      if (@signals)
      {
        print STDERR ('gmmproc: Unwrapped signals:',
                      map($$_{class} . '::' . $$_{name}, @signals));
      }
    }
  }

  exit 0;
}

sub process_list_file ($)
{
  my $path = shift;
  my $file = IO::File->new ($path, 'r');

  unless (defined ($file))
  {
    print STDERR join ('', 'Couldn\'t open file: ', $path, "\n");
    exit 1;
  }

  while (my $line = <$file>)
  {
    if ($line =~ /^\s*#/)
    {
      next;
    }
    # strip everything from the beginning of the line to the `='.
    $line =~ s/.*=//g;
    # strip trailing backslash.
    $line =~ s/\\$//g;
    # strip leading and trailing whitespaces.
    $line =~ s/^\s*(\S*)\s*$/$1/g;
    if ($line)
    {
      push (@{$glob_templates_a_r}, $line);
    }
  }
}

sub add_file_to_list ($)
{
  push (@{$glob_templates_a_r}, shift);
}
