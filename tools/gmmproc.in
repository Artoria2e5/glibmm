#! @PERL@
# -*- mode: perl; perl-indent-level: 2; indent-tabs-mode: nil -*-
#
# @configure_input@
#
######################################################################
# gmmproc (version 5)
######################################################################
#
# *** WARNING: Only modify gmmproc.in. gmmproc is built. ***
#
# Copyright 2001 Karl Einar Nelson, Murray Cumming
# Copyright 2011, 2012 Krzesimir Nowak <qdlacz@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
#
######################################################################

use strict;
use warnings;
use IO::File;
use Getopt::Long qw(:config permute);

require Gir::Parser;
require Gir::Repositories;
require Common::Gmmproc;

# prototypes
sub print_usage ();
sub process_list_file ($$$);
sub print_help ($);
sub add_file_to_list ($$);
sub main ();

main ();

####################################################################


sub print_usage ()
{
  print <<GMMPROC_USAGE;
Usage: gmmproc [options] -s|--source dir -d|--destination dir
       (-l|--list file)|(name1 [name2 [name3 [name4 ...]]])

Options:
  -s dir
  --source dir                     Specify source directory with template files.

  -d dir
  --destination dir                Specify destination directory for generated
                                   files.

  -l file
  --list file                      Specify a file path containing list of
                                   templates to process.

  -h
  --help                           This usage message.

  -g
  --debug                          Leave intermediate output arround for
                                   analysis.Alternatively, set GMMPROC_DEBUG=1
                                   in the environment.

  -u
  --unwrapped                      Warn about possible unwrapped functions.

  -m module
  --mm-module module               Specify a name of mm module. Examples: gtkmm,
                                   glibmm.

  -w namespace
  --wrap-init-namespace namespace  Specify a namespace in which wrap_init()
                                   resides. Examples: Gtk, Gnome::Canvas

  -i include_path
  --include include path           Include paths for proc files. Be sure to
                                   specify the type info directory of current
                                   project (it is usually something like
                                   $(top_srcdir)/codegen/proc) as a first one.

This will read template files from source directory and generate files
to destination directory:
(srcdir/template.{h,cc}g => destdir/{template.{h,cc},private/template_p.h}).
And also, gmmproc will generate a wrap_init.cc file in destination directory.

Templates files can be given as either a file containing list of files or passed
explicitly as a param or both.
GMMPROC_USAGE
}

sub print_help ($)
{
  print_usage ();
  exit (0);
}

sub main ()
{
  my $source_dir = undef;
  my $destination_dir = undef;
  my $unwrapped = 0;
  my $gir_basename = undef;
  my $templates = [];
  my $include_paths = [];
  my $debug = (exists $ENV{'GMMPROC_DEBUG'}) ? $ENV{'GMMPROC_DEBUG'} : 0;
  my $mm_module = undef;
  my $wrap_init_namespace = undef;
  my $opt_parse_result = GetOptions
  (
    'help|h' => \&print_help,
    'source|s=s' => \$source_dir,
    'destination|d=s' => \$destination_dir,
    'list|l=s' => sub { process_list_file ($templates, shift, shift) },
    'unwrapped|u' => \$unwrapped,
    'gir|r=s' => \$gir_basename,
    'include|i=s@' => \$include_paths,
    'debug|g' => \$debug,
    'mm-module|m=s' => \$mm_module,
    'wrap-init-namespace|w=s' => \$wrap_init_namespace,
    '<>' => sub { add_file_to_list ($templates, shift); }
  );

# TODO: print what is wrong.
  if (not $opt_parse_result or not $source_dir or not $destination_dir or
      not $mm_module or @{$templates} < 1 or not $gir_basename or
      @{$include_paths} < 1 or not $wrap_init_namespace)
  {
    print_usage;
    exit 1;
  }

  eval
  {
    my $gir_parser = Gir::Parser->new;

    $gir_parser->parse_file ($gir_basename);

    my $repositories = $gir_parser->get_repositories;
    my $gmmproc = Common::Gmmproc->new ($repositories, $mm_module, $include_paths, $wrap_init_namespace);

# TODO: move it to constructor.
    $gmmproc->set_source_dir ($source_dir);
    $gmmproc->set_destination_dir ($destination_dir);

    for my $template (@{$templates})
    {
      $gmmproc->add_base ($template);
    }

    $gmmproc->parse_and_generate;

# TODO: info about unwrapped information should be written to a logfile.
    if ($unwrapped)
    {
# TODO: warn about unwrapped stuff.
    }
  };
  die $@ if $@;
# TODO: catch the exception.

  exit 0;
}

sub process_list_file ($$$)
{
  my $templates = shift;
  my $option = shift;
  my $path = shift;
  my $file = IO::File->new ($path, 'r');

  unless (defined $file)
  {
    print STDERR 'Could not open file: ' . $path . "\n";
    exit 1;
  }

  while (my $line = <$file>)
  {
    if ($line =~ /^\s*#/)
    {
      next;
    }
    # strip everything from the beginning of the line to the `='.
    $line =~ s/^.*=//g;
    # strip trailing backslash.
    $line =~ s/\\$//g;
    # strip leading and trailing whitespaces.
    $line =~ s/^\s*(\S*)\s*$/$1/g;
    if ($line)
    {
      push @{$templates}, $line;
    }
  }
}

sub add_file_to_list ($$)
{
  my $templates = shift;
  my $file = shift;

  push @{$templates}, $file;
}
