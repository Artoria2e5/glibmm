// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* Copyright (C) 2007 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gio/gio.h>
#include <string>
#include <glibmm/error.h>
#include <glibmm/interface.h>
#include <glibmm/asyncresult.h>
#include <glibmm/fileattribute.h>
#include <glibmm/fileenumerator.h>
#include <glibmm/fileinfo.h>
#include <glibmm/fileinputstream.h>
#include <glibmm/fileoutputstream.h>
#include <glibmm/mountoperation.h>
#include <glibmm/volume.h>

_DEFS(giomm,gio)
_PINCLUDE(glibmm/private/interface_p.h)

namespace Gio {

_WRAP_ENUM(FileQueryInfoFlags, GFileQueryInfoFlags, NO_GTYPE)
_WRAP_ENUM(FileCreateFlags, GFileCreateFlags, NO_GTYPE)
_WRAP_ENUM(FileCopyFlags, GFileCopyFlags, NO_GTYPE)
_WRAP_ENUM(FileMonitorFlags, GFileMonitorFlags, NO_GTYPE)

class File : public Glib::Interface
{
  _CLASS_INTERFACE(File, GFile, G_FILE, GFileIface)

public:
  _IGNORE(g_file_new_for_path)
  _IGNORE(g_file_new_for_uri)
  _IGNORE(g_file_new_for_commandline_arg)
  _IGNORE(g_file_parse_name)

  // Although this is an interface, it is possible to create objects using
  // its static create* members. In the implementation, these would lead
  // to functions of the default GVfs implementation, which, in case of
  // this class' create methods, would rely on concrete GFile implementations
  // such as GLocalFile and GDummyFile.
  static Glib::RefPtr<File> create_for_path(const std::string& path);
  static Glib::RefPtr<File> create_for_uri(const std::string& uri);
  static Glib::RefPtr<File> create_for_commandline_arg(const std::string& arg);

  // parse_name is a UTF8-guaranteed "nice" string that can both
  // be resolved to a GFile (via create_for_parse_name) and put in
  // e.g. a GtkEntry. In practice, it is either a UTF8-only absolute
  // filename (if it starts with a /), or an IRI (i.e. a URI that allows
  // UTF8-encoded unicode chars instead of escaping them).
  static Glib::RefPtr<File> create_for_parse_name(const Glib::ustring& parse_name);

  _WRAP_METHOD(Glib::RefPtr<File> dup() const, g_file_dup)

  // The method intended to be used for making hash tables
  // (g_hash_table_new in C).
  _WRAP_METHOD(guint hash() const, g_file_hash)

  //TODO: Add a comment about why this is virtual:
  _IGNORE(g_file_equal)
  virtual bool equal(const Glib::RefPtr<File>& other) const;

  _WRAP_METHOD(std::string get_basename() const, g_file_get_basename)
  _WRAP_METHOD(std::string get_path() const, g_file_get_path)
  _WRAP_METHOD(std::string get_uri() const, g_file_get_uri)
  _WRAP_METHOD(Glib::ustring get_parse_name() const, g_file_get_parse_name)

  //Note that these return a reference (usually new instances, 
  //so we don't need to use refreturn.

  //TODO: Do we need const and unconst versions of these get_*() methods,
  //or do we consider that the returned File cannot be used to change "this".
  //murrayc.
  _WRAP_METHOD(Glib::RefPtr<File> get_parent() const,
               g_file_get_parent)

  _WRAP_METHOD(Glib::RefPtr<File> get_child(const std::string& name) const,
               g_file_get_child)

  _WRAP_METHOD(Glib::RefPtr<File> get_child_for_display_name(const std::string& display_name) const,
               g_file_get_child_for_display_name,
               errthrow)

  _WRAP_METHOD(bool contains_file(const Glib::RefPtr<File>& descendant) const,
               g_file_contains_file)

  _WRAP_METHOD(std::string get_relative_path(const Glib::RefPtr<File>& descendant) const,
               g_file_get_relative_path)

  _WRAP_METHOD(Glib::RefPtr<File> resolve_relative_path(const std::string& relative_path) const,
               g_file_resolve_relative_path)

  _WRAP_METHOD(bool is_native() const, g_file_is_native)

  _WRAP_METHOD(bool has_uri_scheme(const std::string& uri_scheme) const,
               g_file_has_uri_scheme)

  _WRAP_METHOD(std::string get_uri_scheme() const, g_file_get_uri_scheme)

  _WRAP_METHOD(Glib::RefPtr<FileInputStream> read(const Glib::RefPtr<Cancellable>& cancellable),
               g_file_read,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileInputStream> read(const Glib::RefPtr<Cancellable>& cancellable) const,
               g_file_read,
               refreturn, constversion, errthrow)

  _IGNORE(g_file_read_async)
  void read_async(int io_priority,
                  Glib::RefPtr<Cancellable>& cancellable,
                  const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileInputStream> read_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_read_finish,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> append_to(FileCreateFlags flags,
                                                        const Glib::RefPtr<Cancellable>& cancellable),
               g_file_append_to,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> create(FileCreateFlags flags,
                                                     const Glib::RefPtr<Cancellable>& cancellable),
               g_file_create,
               refreturn, errthrow)

  // TODO: see what etags are for. It seems that it can be null.
  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> replace(const std::string& etag,
                                                      bool make_backup,
                                                      FileCreateFlags flags,
                                                      const Glib::RefPtr<Cancellable>& cancellable),
               g_file_replace,
               refreturn, errthrow)

  _IGNORE(g_file_append_to_async)
  void append_to_async(FileCreateFlags flags,
                       int io_priority,
                       const Glib::RefPtr<Cancellable>& cancellable,
                       const SlotAsyncReady& slot);

  void append_to_async(FileCreateFlags flags,
                       int io_priority,
                       const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> append_to_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_append_to_finish,
               refreturn, errthrow)

  _IGNORE(g_file_create_async)
  void create_async(FileCreateFlags flags,
                    int io_priority,
                    const Glib::RefPtr<Cancellable>& cancellable,
                    const SlotAsyncReady& slot);

  void create_async(FileCreateFlags flags,
                    int io_priority,
                    const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> create_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_create_finish,
               refreturn, errthrow)

  _IGNORE(g_file_replace_async)
  void replace_async(const std::string& etag,
                     bool make_backup,
                     FileCreateFlags flags,
                     int io_priority,
                     const Glib::RefPtr<Cancellable>& cancellable,
                     const SlotAsyncReady& slot);

  void replace_async(const std::string& etag,
                     bool make_backup,
                     FileCreateFlags flags,
                     int io_priority,
                     const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileOutputStream> replace_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_replace_finish,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileInfo> query_info(const std::string& attributes,
                                                 FileQueryInfoFlags flags,
                                                 const Glib::RefPtr<Cancellable>& cancellable),
               g_file_query_info,
               refreturn, errthrow)

  _IGNORE(g_file_query_info_async)
  void query_info_async(const std::string& attributes,
                        FileQueryInfoFlags flags,
                        int io_priority,
                        const Glib::RefPtr<Cancellable>& cancellable,
                        const SlotAsyncReady& slot);

  void query_info_async(const std::string& attributes,
                        FileQueryInfoFlags flags,
                        int io_priority,
                        const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileInfo> query_info_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_query_info_finish,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileInfo> query_filesystem_info(const std::string& attributes,
                                                            const Glib::RefPtr<Cancellable>& cancellable),
               g_file_query_filesystem_info,
               refreturn, errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileEnumerator> enumerate_children(const std::string& attributes,
                                                               FileQueryInfoFlags flags,
                                                               const Glib::RefPtr<Cancellable>& cancellable),
               g_file_enumerate_children,
               errthrow)

  _IGNORE(g_file_enumerate_children_async)
  void enumerate_children_async(const std::string& attributes,
                                FileQueryInfoFlags flags,
                                int io_priority,
                                const Glib::RefPtr<Cancellable>& cancellable,
                                const SlotAsyncReady& slot);

  void enumerate_children_async(const std::string& attributes,
                                FileQueryInfoFlags flags,
                                int io_priority,
                                const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<FileEnumerator> enumerate_children_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_enumerate_children_finish,
               errthrow)

  _WRAP_METHOD(Glib::RefPtr<File> set_display_name(const std::string& display_name,
                                                   const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_display_name,
               refreturn, errthrow)

  _IGNORE(g_file_set_display_name_async)
  void set_display_name_async(const std::string& display_name,
                              int io_priority,
                              const Glib::RefPtr<Cancellable>& cancellable,
                              const SlotAsyncReady& slot);

  void set_display_name_async(const std::string& display_name,
                              int io_priority,
                              const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<File> set_display_name_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_set_display_name_finish,
               errthrow)

  //TODO: remember to add the docs manually, as we name the method differently.
   _WRAP_METHOD(bool remove(const Glib::RefPtr<Cancellable>& cancellable),
                g_file_delete,
                errthrow)

  _WRAP_METHOD(bool trash(const Glib::RefPtr<Cancellable>& cancellable),
               g_file_trash,
               errthrow)

  _IGNORE(g_file_copy)

  /** A signal handler would be, for instance:
   * void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);
   */
  typedef sigc::slot<void, goffset, goffset> SlotFileProgress;

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  bool copy(const Glib::RefPtr<File>& destination,
            FileCopyFlags flags,
            const Glib::RefPtr<Cancellable>& cancellable,
            const SlotFileProgress& slot);

  bool copy(const Glib::RefPtr<File>& destination,
	    FileCopyFlags flags,
	    const SlotFileProgress& slot);
#else
  bool copy(const Glib::RefPtr<File>& destination,
            FileCopyFlags flags,
            const Glib::RefPtr<Cancellable>& cancellable,
            const SlotFileProgress& slot,
            std::auto_ptr<Glib::Error>& error);

  bool copy(const Glib::RefPtr<File>& destination,
	    FileCopyFlags flags,
	    const SlotFileProgress& slot,
	    std::auto_ptr<Glib::Error>& error);
#endif // GLIBMM_EXCEPTIONS_ENABLED

  _IGNORE(g_file_move)

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  bool move(const Glib::RefPtr<File>& destination,
            FileCopyFlags flags,
            const Glib::RefPtr<Cancellable>& cancellable,
            const SlotFileProgress& slot);

  bool move(const Glib::RefPtr<File>& destination,
	    FileCopyFlags flags,
	    const SlotFileProgress& slot);
#else
  bool move(const Glib::RefPtr<File>& destination,
            FileCopyFlags flags,
            const Glib::RefPtr<Cancellable>& cancellable,
            const SlotFileProgress& slot,
            std::auto_ptr<Glib::Error>& error);

  bool move(const Glib::RefPtr<File>& destination,
	    FileCopyFlags flags,
	    const SlotFileProgress& slot,
	    std::auto_ptr<Glib::Error>& error);
#endif // GLIBMM_EXCEPTIONS_ENABLED

  _WRAP_METHOD(bool make_directory(const Glib::RefPtr<Cancellable>& cancellable),
               g_file_make_directory,
               errthrow)

  _WRAP_METHOD(bool make_symbolic_link(const std::string& symlink_value,
                                       const Glib::RefPtr<Cancellable>& cancellable),
               g_file_make_symbolic_link,
               errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileAttributeInfoList> query_settable_attributes(const Glib::RefPtr<Cancellable>& cancellable),
               g_file_query_settable_attributes,
               errthrow)

  _WRAP_METHOD(Glib::RefPtr<FileAttributeInfoList> query_writable_namespaces(const Glib::RefPtr<Cancellable>& cancellable),
               g_file_query_writable_namespaces,
               errthrow)

  _WRAP_METHOD(bool set_attributes_from_info(const Glib::RefPtr<FileInfo>& info,
                                             FileQueryInfoFlags flags,
                                             const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attributes_from_info,
               errthrow)

  _IGNORE(g_file_set_attributes_async)
  void set_attributes_async(const Glib::RefPtr<FileInfo>& info,
                            FileQueryInfoFlags flags,
                            int io_priority,
                            const Glib::RefPtr<Cancellable>& cancellable,
                            const SlotAsyncReady& slot);

  void set_attributes_async(const Glib::RefPtr<FileInfo>& info,
                            FileQueryInfoFlags flags,
                            int io_priority,
                            const SlotAsyncReady& slot);

  _IGNORE(g_file_set_attributes_finish) // takes GFileInfo**

#ifdef GLIBMM_EXCEPTIONS_ENABLED
  bool set_attributes_finish(const Glib::RefPtr<AsyncResult>& result,
                             const Glib::RefPtr<FileInfo>& info);
#else
  bool set_attributes_finish(const Glib::RefPtr<AsyncResult>& result,
                             const Glib::RefPtr<FileInfo>& info,
                             std::auto_ptr<Glib::Error>& error);
#endif // GLIBMM_EXCEPTIONS_ENABLED

  _WRAP_METHOD(bool set_attribute_string(const std::string& attribute,
                                         const std::string& value,
                                         FileQueryInfoFlags flags,
                                         const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_string,
               errthrow)

  _WRAP_METHOD(bool set_attribute_byte_string(const std::string& attribute,
                                              const std::string& value,
                                              FileQueryInfoFlags flags,
                                              const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_byte_string,
               errthrow)

  _WRAP_METHOD(bool set_attribute_uint32(const std::string& attribute,
                                         guint32 value,
                                         FileQueryInfoFlags flags,
                                         const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_uint32,
               errthrow)

  _WRAP_METHOD(bool set_attribute_int32(const std::string& attribute,
                                        gint32 value,
                                        FileQueryInfoFlags flags,
                                        const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_int32,
               errthrow)

  _WRAP_METHOD(bool set_attribute_uint64(const std::string& attribute,
                                         guint64 value,
                                         FileQueryInfoFlags flags,
                                         const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_uint64,
               errthrow)

  _WRAP_METHOD(bool set_attribute_int64(const std::string& attribute,
                                        gint64 value,
                                        FileQueryInfoFlags flags,
                                        const Glib::RefPtr<Cancellable>& cancellable),
               g_file_set_attribute_int64,
               errthrow)

  _IGNORE(g_file_mount_mountable)
  void mount_mountable(const Glib::RefPtr<MountOperation>& mount_operation,
                       const Glib::RefPtr<Cancellable>& cancellable,
                       const SlotAsyncReady& slot);

  void mount_mountable(const Glib::RefPtr<MountOperation>& mount_operation,
                       const SlotAsyncReady& slot);

  _WRAP_METHOD(Glib::RefPtr<File> mount_mountable_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_mount_mountable_finish,
               refreturn, errthrow)

  _IGNORE(g_file_unmount_mountable)
  void unmount_mountable(const Glib::RefPtr<Cancellable>& cancellable,
                         const SlotAsyncReady& slot);

  void unmount_mountable(const SlotAsyncReady& slot);

  _WRAP_METHOD(bool unmount_mountable_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_unmount_mountable_finish,
               errthrow)

  _IGNORE(g_file_eject_mountable)
  void eject_mountable(const Glib::RefPtr<Cancellable>& cancellable,
                       const SlotAsyncReady& slot);

  void eject_mountable(const SlotAsyncReady& slot);

  _WRAP_METHOD(bool eject_mountable_finish(const Glib::RefPtr<AsyncResult>& result),
               g_file_eject_mountable_finish,
               errthrow)

  // TODO: g_file_monitor_*

  //TODO: atm I don't understand what's etag_out:
  // "a pointer to the current entity tag for the document" - sounds like it
  // should be kept as char**
  _WRAP_METHOD(bool load_contents(const Glib::RefPtr<Cancellable>& cancellable,
                                  char** contents,
                                  gsize& length,
                                  char** etag_out),
               g_file_load_contents,
               errthrow)

  _IGNORE(g_file_load_contents_async)
  void load_contents_async(const Glib::RefPtr<Cancellable>& cancellable,
                           const SlotAsyncReady& slot);

  void load_contents_async(const SlotAsyncReady& slot);

  _WRAP_METHOD(bool load_contents_finish(const Glib::RefPtr<AsyncResult>& result,
                                         char** contents,
                                         gsize& length,
                                         char** etag_out),
               g_file_load_contents_finish,
               errthrow)

  _IGNORE(g_file_load_partial_contents_async)
  void load_partial_contents_async(const Glib::RefPtr<Cancellable>& cancellable,
                                   const SlotAsyncReady& slot);

  /** A signal handler would be, for instance:
   * bool on_read_more(const char* file_contents, goffset file_size);
   */
  typedef sigc::slot<bool, const char*, goffset> SlotReadMore;

  void load_partial_contents_async(const Glib::RefPtr<Cancellable>& cancellable,
                                   const SlotReadMore& slot_read_more,
                                   const SlotAsyncReady& slot_async_ready);

  void load_partial_contents_async(const SlotReadMore& slot_read_more,
                                   const SlotAsyncReady& slot_async_ready);

  _WRAP_METHOD(bool load_partial_contents_finish(const Glib::RefPtr<AsyncResult>& result,
                                                 char** contents,
                                                 gsize& length,
                                                 char** etag_out),
               g_file_load_partial_contents_finish,
               errthrow)

  _WRAP_METHOD(void replace_contents(const char* contents,
                                     gsize length,
                                     const char* etag,
                                     bool make_backup,
                                     FileCreateFlags flags,
                                     char** new_etag,
                                     const Glib::RefPtr<Cancellable>& cancellable),
               g_file_replace_contents,
               errthrow)

  _IGNORE(g_file_replace_contents_async)
  void replace_contents_async(const char* contents,
                              gsize length,
                              const char* etag,
                              bool make_backup,
                              FileCreateFlags flags,
                              const Glib::RefPtr<Cancellable>& cancellable,
                              const SlotAsyncReady& slot);

  void replace_contents_async(const char* contents,
                              gsize length,
                              const char* etag,
                              bool make_backup,
                              FileCreateFlags flags,
                              const SlotAsyncReady& slot);

  _WRAP_METHOD(void replace_contents_finish(const Glib::RefPtr<AsyncResult>& result,
                                            char** new_etag),
               g_file_replace_contents_finish,
               errthrow)

  // *** vfuncs ***

  _WRAP_VFUNC(Glib::RefPtr<File> dup(), "dup")
  _WRAP_VFUNC(guint hash() const, "hash")
  // no equal() vfunc, there's handwritten virtual equal()

  _WRAP_VFUNC(std::string get_basename() const, "get_basename")
  _WRAP_VFUNC(std::string get_path() const, "get_path")
  _WRAP_VFUNC(std::string get_uri() const, "get_uri")
  _WRAP_VFUNC(std::string get_parse_name() const, "get_parse_name")

  _WRAP_VFUNC(Glib::RefPtr<File> get_parent() const, "get_parent")

  // GFileIface does not define get_child(). Perhaps it's not intentional.
  //  _WRAP_VFUNC(Glib::RefPtr<File> get_child(const std::string& name) const, "get_child")

  // TODO: howto wrap a vfunc that takes a GError**
//   _WRAP_VFUNC(Glib::RefPtr<File> get_child_for_display_name(const std::string& display_name) const,
//               "get_child_for_display_name",
//               errthrow)

  _WRAP_VFUNC(bool contains_file(const Glib::RefPtr<File>& descendant) const,
              "contains_file")

  _WRAP_VFUNC(std::string get_relative_path(const Glib::RefPtr<File>& descendant) const,
              "get_relative_path")

  _WRAP_VFUNC(Glib::RefPtr<File> resolve_relative_path(const std::string& relative_path) const,
              "resolve_relative_path")

  _WRAP_VFUNC(bool is_native() const, "is_native")
  _WRAP_VFUNC(bool has_uri_scheme(const std::string& uri_scheme) const, "has_uri_scheme")
};

/** @relates Gio::File */
inline bool operator==(const Glib::RefPtr<File>& lhs, const Glib::RefPtr<File>& rhs)
{ return lhs->equal(rhs); }

/** @relates Gio::File */
inline bool operator!=(const Glib::RefPtr<File>& lhs, const Glib::RefPtr<File>& rhs)
{ return ! lhs->equal(rhs); }

} // namespace Gio
