// -*- Mode: C++; indent-tabs-mode: nil; c-basic-offset: 2 -*-

/* Copyright (C) 2010 The giomm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/object.h>
#include <giomm/initable.h>
#include <giomm/asyncinitable.h>
#include <giomm/iostream.h>
#include <giomm/asyncresult.h>
#include <giomm/credentials.h>
#include <giomm/dbusmessage.h>

_DEFS(giomm,gio)
_PINCLUDE(glibmm/private/object_p.h)

//TODO: Use a GDbus namespace, and remove the DBus prefixes.
namespace Gio
{

_WRAP_ENUM(BusType, GBusType)
_WRAP_ENUM(DBusConnectionFlags, GDBusConnectionFlags, NO_GTYPE)
_WRAP_ENUM(DBusSendMessageFlags, GDBusSendMessageFlags, NO_GTYPE)
_WRAP_ENUM(DBusCallFlags, GDBusCallFlags, NO_GTYPE)

class DBusAuthObserver;

//TODO: Add example from C API in class docs.
/** DBusConnection - D-Bus Connections.
 * The DBusConnection type is used for D-Bus connections to remote peers such
 * as a message buses. It is a low-level API that offers a lot of flexibility.
 * For instance, it lets you establish a connection over any transport that
 * can by represented as an IOStream.
 *
 * This class is rarely used directly in D-Bus clients. If you are writing an
 * D-Bus client, it is often easier to use the Gio::DBus::own_name(),
 * Gio::DBus::watch_name() or DBusProxy::create_for_bus() APIs.
 *
 * @newin{2,28}
 */
class DBusConnection
: public Glib::Object, public Initable, public AsyncInitable
{
protected:
  _CLASS_GOBJECT(DBusConnection, GDBusConnection, G_DBUS_CONNECTION, Glib::Object, GObject)
  _IMPLEMENTS_INTERFACE(Initable)
  _IMPLEMENTS_INTERFACE(AsyncInitable)

protected:

  DBusConnection(const Glib::RefPtr<IOStream>& stream,
    const Glib::ustring& guid, const Glib::RefPtr<DBusAuthObserver>& observer,
    const SlotAsyncReady& slot, DBusConnectionFlags flags,
    const Glib::RefPtr<Cancellable>& cancellable);

  DBusConnection(const Glib::RefPtr<IOStream>& stream,
    const Glib::ustring& guid, const Glib::RefPtr<DBusAuthObserver>& observer,
    DBusConnectionFlags flags, const Glib::RefPtr<Cancellable>& cancellable);

  DBusConnection(const Glib::ustring& address,
    const Glib::RefPtr<DBusAuthObserver>& observer,
    const SlotAsyncReady& slot, DBusConnectionFlags flags,
    const Glib::RefPtr<Cancellable>& cancellable);

  DBusConnection(const Glib::ustring& address,
    const Glib::RefPtr<DBusAuthObserver>& observer,
    DBusConnectionFlags flags, const Glib::RefPtr<Cancellable>& cancellable);

public:

  /** Asynchronously connects to the message bus specified by @a bus_type.
   *
   * When the operation is finished, @a slot will be invoked. You can then
   * call get_finish() to get the result of the operation.
   *
   * This is a asynchronous failable function. See get_sync() for the
   * synchronous version.
   *
   * @param bus_type A BusType.
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   * @param cancellable A Cancellable.
   *
   * @newin{2,28}
   */
  void get(BusType bus_type, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());
  _IGNORE(g_bus_get)

  /** @throw Glib::Error.
   */
  _WRAP_METHOD(static Glib::RefPtr<DBusConnection> get_finish(const Glib::RefPtr<AsyncResult>& res), g_bus_get_finish, errthrow)

  _WRAP_METHOD_DOCS_ONLY(g_dbus_connection_new)
  void create(const Glib::RefPtr<IOStream>& stream,
    const Glib::ustring& guid, const Glib::RefPtr<DBusAuthObserver>& observer,
    const SlotAsyncReady& slot,
    DBusConnectionFlags flags = Gio::DBUS_CONNECTION_FLAGS_NONE,
    const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());

  /// @throw Glib::Error.
  _WRAP_METHOD(static Glib::RefPtr<DBusConnection> create_finish(const Glib::RefPtr<AsyncResult>& res), g_dbus_connection_new_finish, errthrow)

  _WRAP_METHOD_DOCS_ONLY(g_dbus_connection_new_for_address)
  void create_for_address(const Glib::ustring& address,
    const Glib::RefPtr<DBusAuthObserver>& observer, const SlotAsyncReady& slot,
    DBusConnectionFlags flags = Gio::DBUS_CONNECTION_FLAGS_NONE,
    const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());

  /// @throw Glib::Error.
  _WRAP_METHOD(static Glib::RefPtr<DBusConnection> create_for_address_finish(const Glib::RefPtr<AsyncResult>& res), g_dbus_connection_new_for_address_finish, errthrow)

  _WRAP_METHOD_DOCS_ONLY(g_dbus_connection_new_sync)
  /** @throw Glib::Error.
   */
  Glib::RefPtr<DBusConnection> create(const Glib::RefPtr<IOStream>& stream,
    const Glib::ustring& guid, const Glib::RefPtr<DBusAuthObserver>& observer,
    DBusConnectionFlags flags = Gio::DBUS_CONNECTION_FLAGS_NONE,
    const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());

  _WRAP_METHOD_DOCS_ONLY(g_dbus_connection_new_for_address_sync)
  /** @throw Glib::Error.
   */
  Glib::RefPtr<DBusConnection> create_for_address(const Glib::ustring& address,
    const Glib::RefPtr<DBusAuthObserver>& observer,
    DBusConnectionFlags flags = Gio::DBUS_CONNECTION_FLAGS_NONE,
    const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());

  /** Closes the connection. Note that this never causes the process to exit
   * (this might only happen if the other end of a shared message bus
   * connection disconnects, see property_exit_on_close()).
   *
   * Once the connection is closed, operations such as sending a message will
   * return with the error Gio::IO_ERROR_CLOSED. Closing a connection will not
   * automatically flush the connection so queued messages may be lost. Use
   * flush() if you need such guarantees.
   *
   * If the connection is already closed, this method fails with
   * Gio::IO_ERROR_CLOSED.
   *
   * When the connection has been closed, the "closed" signal is emitted in
   * the thread-default main loop of the thread that connection was
   * constructed in.
   *
   * This is an asynchronous method.  See close_sync() for the synchronous
   * version.
   *
   * @newin{2,28}
   */
  void close();

  /** Closes the connection. Note that this never causes the process to exit
   * (this might only happen if the other end of a shared message bus
   * connection disconnects, see property_exit_on_close()).
   *
   * Once the connection is closed, operations such as sending a message will
   * return with the error Gio::IO_ERROR_CLOSED. Closing a connection will not
   * automatically flush the connection so queued messages may be lost. Use
   * flush() if you need such guarantees.
   *
   * If the connection is already closed, this method fails with
   * Gio::IO_ERROR_CLOSED.
   *
   * When the connection has been closed, the "closed" signal is emitted in
   * the thread-default main loop of the thread that connection was
   * constructed in.
   *
   * This is an asynchronous method. When the operation is finished, @a slot
   * will be invoked in the thread-default main loop of the thread you are
   * calling this method from. You can then call close_finish() to get the
   * result of the operation. See close_sync() for the synchronous version.
   *
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   * @param cancellable A Cancellable.
   *
   * @newin{2,28}
   */
  void close(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable);

  /** Closes the connection. Note that this never causes the process to exit
   * (this might only happen if the other end of a shared message bus
   * connection disconnects, see property_exit_on_close()).
   *
   * Once the connection is closed, operations such as sending a message will
   * return with the error Gio::IO_ERROR_CLOSED. Closing a connection will not
   * automatically flush the connection so queued messages may be lost. Use
   * flush() if you need such guarantees.
   *
   * If the connection is already closed, this method fails with
   * Gio::IO_ERROR_CLOSED.
   *
   * When the connection has been closed, the "closed" signal is emitted in
   * the thread-default main loop of the thread that connection was
   * constructed in.
   *
   * This is an asynchronous method. When the operation is finished, @a slot
   * will be invoked in the thread-default main loop of the thread you are
   * calling this method from. You can then call close_finish() to get the
   * result of the operation. See close_sync() for the synchronous version.
   *
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   *
   * @newin{2,28}
   */
  void close(const SlotAsyncReady& slot);
  _IGNORE(g_dbus_connection_close)

  _WRAP_METHOD(bool close_finish(const Glib::RefPtr<AsyncResult>& result),
               g_dbus_connection_close_finish, errthrow)

  /** Synchronously closees the connection. The calling thread is blocked
   * until this is done. See close() for the asynchronous version of this
   * method and more details about what it does.
   *
   * @newin{2,28}
   *
   * @throw Glib::Error.
   */
  void close_sync();

  _WRAP_METHOD(void close_sync(const Glib::RefPtr<Cancellable>& cancellable), g_dbus_connection_close_sync, errthrow)

  /** Asynchronously flushes the connection, that is, writes all queued
   * outgoing message to the transport and then flushes the transport (using
   * Gio::OutputStream::flush_async()). This is useful in programs that wants
   * to emit a D-Bus signal and then exit immediately. Without flushing the
   * connection, there is no guarantee that the message has been sent to the
   * networking buffers in the OS kernel.
   *
   * This is an asynchronous method. See flush_sync() for the synchronous
   * version.
   *
   * @newin{2,28}
   */
  void flush();

  /** Asynchronously flushes the connection, that is, writes all queued
   * outgoing message to the transport and then flushes the transport (using
   * Gio::OutputStream::flush_async()). This is useful in programs that wants
   * to emit a D-Bus signal and then exit immediately. Without flushing the
   * connection, there is no guarantee that the message has been sent to the
   * networking buffers in the OS kernel.
   *
   * This is an asynchronous method. When the operation is finished, @a slot
   * will be invoked in the thread-default main loop of the thread you are
   * calling this method from. You can then call flush_finish() to get the
   * result of the operation. See flush_sync() for the synchronous version.
   *
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   * @param cancellable A Cancellable.
   *
   * @newin{2,28}
   */
  void flush(const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable);

  /** Asynchronously flushes the connection, that is, writes all queued
   * outgoing message to the transport and then flushes the transport (using
   * Gio::OutputStream::flush_async()). This is useful in programs that wants
   * to emit a D-Bus signal and then exit immediately. Without flushing the
   * connection, there is no guarantee that the message has been sent to the
   * networking buffers in the OS kernel.
   *
   * This is an asynchronous method. When the operation is finished, @a slot
   * will be invoked in the thread-default main loop of the thread you are
   * calling this method from. You can then call flush_finish() to get the
   * result of the operation. See flush_sync() for the synchronous version.
   *
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   *
   * @newin{2,28}
   */
  void flush(const SlotAsyncReady& slot);
  _IGNORE(g_dbus_connection_flush)

  _WRAP_METHOD(bool flush_finish(const Glib::RefPtr<AsyncResult>& result),
               g_dbus_connection_flush_finish, errthrow)

  /** Synchronously flushes the connection. The calling thread is blocked
   * until this is done. See flush() for the asynchronous version of this
   * method and more details about what it does.
   *
   * @newin{2,28}
   *
   * @throw Glib::Error.
   */
  void flush_sync();

  _WRAP_METHOD(void flush_sync(const Glib::RefPtr<Cancellable>& cancellable), g_dbus_connection_flush_sync, errthrow)

  //TODO: In the C API, out_serial is volatile, but gmmproc can't parse that.
  #m4 _CONVERSION(`guint32*',`volatile guint32*',`($3)')
  _WRAP_METHOD(bool send_message(const Glib::RefPtr<DBusMessage>& message, DBusSendMessageFlags flags, guint32* out_serial), g_dbus_connection_send_message, errthrow)

  /** Asynchronously sends message to the peer represented by connection.
   *
   * Unless flags contain the Gio::DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL
   * flag, the serial number will be assigned by connection and set on message
   * via Gio::DBusMessage::set_serial().
   *
   * If the connection is closed then the operation will fail with
   * Gio::IO_ERROR_CLOSED. If @a cancellable is canceled, the operation will
   * fail with Gio::IO_ERROR_CANCELLED. If @a message is not well-formed, the
   * operation fails with Gio::IO_ERROR_INVALID_ARGUMENT.
   *
   * This is an asynchronous method. When the operation is finished, @a slot
   * will be invoked in the thread-default main loop of the thread you are
   * calling this method from. You can then call
   * send_message_with_reply_finish() to get the result of the operation. See
   * send_message_with_reply_sync() for the synchronous version.
   *
   * Note that message must be unlocked, unless flags contain the
   * Gio::DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
   *
   * See the C API docs for examples.
   *
   * @param message A DBusMessage.
   * @param timeout_msec The timeout in milliseconds or -1 to use the default
   * timeout.
   * @param slot A SlotAsyncReady to call when the request is satisfied.
   * @param cancellable A Cancellable.
   *
   * @newin{2,28}
   */
  void send_message_with_reply(const Glib::RefPtr<DBusMessage>& message, int timeout_msec, const SlotAsyncReady& slot, const Glib::RefPtr<Cancellable>& cancellable = Glib::RefPtr<Cancellable>());
  _IGNORE(g_dbus_connection_send_message_with_reply)

  /// @throw Glib::Error.
  _WRAP_METHOD(Glib::RefPtr<DBusMessage> send_message_with_reply_finish(const Glib::RefPtr<AsyncResult>& result), g_dbus_connection_send_message_with_reply_finish, errthrow)

  _WRAP_METHOD(void start_message_processing(), g_dbus_connection_start_message_processing)
  _WRAP_METHOD(bool is_closed() const, g_dbus_connection_is_closed)

  _WRAP_METHOD(Glib::RefPtr<IOStream> get_stream(), g_dbus_connection_get_stream, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const IOStream> get_stream() const, g_dbus_connection_get_stream, refreturn, constversion)

  _WRAP_METHOD(Glib::ustring get_guid() const, g_dbus_connection_get_guid)
  _WRAP_METHOD(Glib::ustring get_unique_name() const, g_dbus_connection_get_unique_name)

  _WRAP_METHOD(Glib::RefPtr<Credentials> get_peer_credentials(), g_dbus_connection_get_peer_credentials, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Credentials> get_peer_credentials() const, g_dbus_connection_get_peer_credentials, refreturn, constversion)

  _WRAP_METHOD(bool get_exit_on_close() const, g_dbus_connection_get_exit_on_close)
  _WRAP_METHOD(void set_exit_on_close(bool exit_on_close = true), g_dbus_connection_set_exit_on_close)
  _WRAP_METHOD(DBusCapabilityFlags get_capabilities() const, g_dbus_connection_get_capabilities)
};


} // namespace Gio
