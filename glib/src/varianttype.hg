/* Copyright 2010 The glibmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

_DEFS(glibmm,glib)

#include <glibmmconfig.h>
#include <glibmm/ustring.h>

namespace Glib
{

/** TODO
 * @newin{2,26}
 * @ingroup glibmmVariant
 */
class VariantType
{
  _CLASS_OPAQUE_COPYABLE(VariantType, GVariantType, NONE, g_variant_type_copy, g_variant_type_free)
  _IGNORE(g_variant_type_copy, g_variant_type_free)
public:

  /** Copy the C item into a new VariantType instance.
   */
  explicit VariantType(const GVariantType* castitem);
  
  VariantType& operator=(const GVariantType* castitem);
  
  //TODO: Use something instead of gsize?
  _WRAP_METHOD(gsize _get_string_length() const, g_variant_type_get_string_length)
  _WRAP_METHOD(Glib::ustring get_string() const, g_variant_type_peek_string)
  _IGNORE(g_variant_type_dup_string)

  _WRAP_METHOD(bool is_definite() const, g_variant_type_is_definite)
  _WRAP_METHOD(bool is_container() const, g_variant_type_is_container)
  _WRAP_METHOD(bool is_basic() const, g_variant_type_is_basic)
  _WRAP_METHOD(bool is_maybe() const, g_variant_type_is_maybe)
  _WRAP_METHOD(bool is_array() const, g_variant_type_is_array)
  _WRAP_METHOD(bool is_tuple() const, g_variant_type_is_tuple)
  _WRAP_METHOD(bool is_dict_entry() const, g_variant_type_is_dict_entry)
  _WRAP_METHOD(bool is_variant() const, g_variant_type_is_variant)

/* subtypes */
  _WRAP_METHOD(bool is_subtype_of(const VariantType& supertype) const, g_variant_type_is_subtype_of)
  
  _WRAP_METHOD(VariantType element() const, g_variant_type_element)
  _WRAP_METHOD(VariantType first() const, g_variant_type_first)
  _WRAP_METHOD(VariantType next () const, g_variant_type_next)
  _WRAP_METHOD(gsize n_items() const, g_variant_type_n_items)
  _WRAP_METHOD(VariantType key() const, g_variant_type_key)
  _WRAP_METHOD(VariantType value() const, g_variant_type_value)
};

extern const VariantType VariantTypeBool;

extern const VariantType VariantTypeByte;

extern const VariantType VariantTypeInt16;

extern const VariantType VariantTypeUint16;

extern const VariantType VariantTypeInt32;

extern const VariantType VariantTypeUint32;

extern const VariantType VariantTypeInt64;

extern const VariantType VariantTypeUint64;

extern const VariantType VariantTypeDouble;

extern const VariantType VariantTypeString;

extern const VariantType VariantTypeObjectPath;

extern const VariantType VariantTypeSignature;

extern const VariantType VariantTypeVariant;

extern const VariantType VariantTypeHandle;

extern const VariantType VariantTypeUnit;

extern const VariantType VariantTypeAny;

extern const VariantType VariantTypeBasic;

extern const VariantType VariantTypeMaybe;

extern const VariantType VariantTypeArray;

extern const VariantType VariantTypeTuple;

extern const VariantType VariantTypeDictEntry;

extern const VariantType VariantTypeDictionary;

extern const VariantType VariantTypeStringArray;

extern const VariantType VariantTypeByteString;

extern const VariantType VariantTypeByteStringArray;



} // namespace Glib
