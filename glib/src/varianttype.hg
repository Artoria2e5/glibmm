/* Copyright 2010 The glibmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

_DEFS(glibmm,glib)

#include <glibmmconfig.h>
#include <glib-object.h> //For gsize
#include <string>

#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GVariantType GVariantType;
#endif //DOXYGEN_SHOULD_SKIP_THIS

namespace Glib
{

/** VariantType - The Glib::VariantBase type system.
 * The Glib::VariantBase type system is based, in large part, on the DBus type
 * system, with two major changes and some minor lifting of restrictions. <a
 * href="http://dbus.freedesktop.org/doc/dbus-specification.html">The
 * DBus specification</a>, therefore, provides a significant amount of
 * information that is useful when working with Glib::VariantBase.
 *
 * The first major change with respect to the DBus type system is the
 * introduction of maybe (or "nullable") types. Any type in Glib::VariantBase
 * can be converted to a maybe type, in which case, "nothing" (or "null")
 * becomes a valid value. Maybe types have been added by introducing the
 * character "m" to type strings.
 *
 * The second major change is that the Glib::VariantBase type system supports
 * the concept of "indefinite types" -- types that are less specific than the
 * normal types found in DBus. For example, it is possible to speak of "an
 * array of any type" in Glib::VariantBase, where the DBus type system would
 * require you to speak of "an array of integers" or "an array of strings".
 * Indefinite types have been added by introducing the characters "*", "?" and
 * "r" to type strings.
 *
 * Finally, all arbitrary restrictions relating to the complexity of types are
 * lifted along with the restriction that dictionary entries may only appear
 * nested inside of arrays.
 *
 * Just as in DBus, Glib::VariantBase types are described with strings ("type
 * strings"). Subject to the differences mentioned above, these strings are of
 * the same form as those found in DBus. Note, however: DBus always works in
 * terms of messages and therefore individual type strings appear nowhere in
 * its interface. Instead, "signatures" are a concatenation of the strings of
 * the type of each argument in a message. Glib::VariantBase deals with single
 * values directly so Glib::VariantBase type strings always describe the type
 * of exactly one value. This means that a DBus signature string is generally
 * not a valid Glib::VariantBase type string -- except in the case that it is
 * the signature of a message containing exactly one argument.
 *
 * An indefinite type is similar in spirit to what may be called an abstract
 * type in other type systems. No value can exist that has an indefinite type
 * as its type, but values can exist that have types that are subtypes of
 * indefinite types. That is to say, Glib::VariantBase::get_type() will never
 * return an indefinite type, but calling Glib::VariantBase::is_of_type() with
 * an indefinite type may return <tt>true</tt>. For example, you can not have a
 * value that represents "an array of no particular type", but you can have an
 * "array of integers" which certainly matches the type of "an array of no
 * particular type", since "array of integers" is a subtype of "array of no
 * particular type".
 *
 * This is similar to how instances of abstract classes may not directly exist
 * in other type systems, but instances of their non-abstract subtypes may. For
 * example, in gtkmm, no object that has the type of Gtk::Bin can exist (since
 * Gtk::Bin is an abstract class), but a Gtk::Window can certainly be
 * instantiated, and you would say that the Gtk::Window is a Gtk::Bin (since
 * Gtk::Window is a subclass of Gtk::Bin).
 *
 * For a detailed description of the Glib::VariantBase type strings see the C
 * API docs of GVariantType.
 * @newin{2,28}
 * @ingroup glibmmVariant
 */
class VariantType
{
  _CLASS_OPAQUE_COPYABLE(VariantType, GVariantType, NONE, g_variant_type_copy, g_variant_type_free)
  _IGNORE(g_variant_type_copy, g_variant_type_free)
public:

  /** Copy the C item into a new VariantType instance.
   */
  explicit VariantType(const GVariantType* castitem);

  //TODO: Docuementation
  explicit VariantType(const std::string& type_string);

  VariantType& operator=(const GVariantType* castitem);


//The C parameters are actually const, but gmmproc doesn't understand that,
//so we add a m4 conversion to satisfy it:
#m4 _CONVERSION(`const VariantType&',`GVariantType*',`($3).gobj()')
  _WRAP_METHOD(static VariantType create_array(const VariantType& element), g_variant_type_new_array)
  _WRAP_METHOD(static VariantType create_maybe(const VariantType& element), g_variant_type_new_maybe)

  //TODO: Use a single list parameter:
  //_WRAP_METHOD(static VariantType create_tuple(const GVariantType * const *items, gint length), g_variant_type_new_tuple)

  _WRAP_METHOD(static VariantType create_dict_entry(const VariantType& key, const VariantType& value), g_variant_type_new_dict_entry)

  //TODO: Use something instead of gsize?
  _WRAP_METHOD(gsize _get_string_length() const, g_variant_type_get_string_length)
  _WRAP_METHOD(std::string get_string() const, g_variant_type_peek_string)
  _IGNORE(g_variant_type_dup_string)

  _WRAP_METHOD(bool is_definite() const, g_variant_type_is_definite)
  _WRAP_METHOD(bool is_container() const, g_variant_type_is_container)
  _WRAP_METHOD(bool is_basic() const, g_variant_type_is_basic)
  _WRAP_METHOD(bool is_maybe() const, g_variant_type_is_maybe)
  _WRAP_METHOD(bool is_array() const, g_variant_type_is_array)
  _WRAP_METHOD(bool is_tuple() const, g_variant_type_is_tuple)
  _WRAP_METHOD(bool is_dict_entry() const, g_variant_type_is_dict_entry)
  _WRAP_METHOD(bool is_variant() const, g_variant_type_is_variant)

  #m4 _CONVERSION(`const VariantType&',`gconstpointer',`const_cast<GVariantType*>(($3).gobj())')
  _WRAP_METHOD(guint hash() const, g_variant_type_hash)
  _WRAP_METHOD(bool equal(const VariantType& other) const, g_variant_type_equal)

  _WRAP_METHOD(bool is_subtype_of(const VariantType& supertype) const, g_variant_type_is_subtype_of)

  _WRAP_METHOD(VariantType element() const, g_variant_type_element)
  _WRAP_METHOD(VariantType first() const, g_variant_type_first)
  _WRAP_METHOD(VariantType next () const, g_variant_type_next)
  _WRAP_METHOD(gsize n_items() const, g_variant_type_n_items)
  _WRAP_METHOD(VariantType key() const, g_variant_type_key)
  _WRAP_METHOD(VariantType value() const, g_variant_type_value)
};

extern const VariantType VariantTypeBool;

extern const VariantType VariantTypeByte;

extern const VariantType VariantTypeInt16;

extern const VariantType VariantTypeUint16;

extern const VariantType VariantTypeInt32;

extern const VariantType VariantTypeUint32;

extern const VariantType VariantTypeInt64;

extern const VariantType VariantTypeUint64;

extern const VariantType VariantTypeDouble;

extern const VariantType VariantTypeString;

extern const VariantType VariantTypeObjectPath;

extern const VariantType VariantTypeSignature;

extern const VariantType VariantTypeVariant;

extern const VariantType VariantTypeHandle;

extern const VariantType VariantTypeUnit;

extern const VariantType VariantTypeAny;

extern const VariantType VariantTypeBasic;

extern const VariantType VariantTypeMaybe;

extern const VariantType VariantTypeArray;

extern const VariantType VariantTypeTuple;

extern const VariantType VariantTypeDictEntry;

extern const VariantType VariantTypeDictionary;

extern const VariantType VariantTypeStringArray;

extern const VariantType VariantTypeByteString;

extern const VariantType VariantTypeByteStringArray;



} // namespace Glib
