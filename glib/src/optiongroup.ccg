// -*- c++ -*-
/* $Id$ */

/* Copyright (C) 2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/optionentry.h>
#include <glibmm/optioncontext.h>
#include <glibmm/utility.h>
#include <glib/goption.h>

namespace Glib
{

namespace //anonymous
{

gboolean g_callback_pre_parse(GOptionContext* context, GOptionGroup* group, gpointer data, GError** /* TODO error */)
{
  OptionContext cppContext(context);
  OptionGroup cppGroup(group); //Maybe this should be option_group.
  
  OptionGroup* option_group = static_cast<OptionGroup*>(data);
  if(option_group)
    return option_group->on_pre_parse(cppContext, cppGroup);
  else
    return false;
}

gboolean g_callback_post_parse(GOptionContext* context, GOptionGroup* group, gpointer data, GError** /* TODO error */)
{
  OptionContext cppContext(context);
  OptionGroup cppGroup(group); //Maybe this should be option_group.
  
  OptionGroup* option_group = static_cast<OptionGroup*>(data);
  if(option_group)
    return option_group->on_post_parse(cppContext, cppGroup);
  else
    return false;
}

void g_callback_error(GOptionContext* context, GOptionGroup* group, gpointer data, GError** /* TODO error*/)
{
  OptionContext cppContext(context);
  OptionGroup cppGroup(group); //Maybe this should be option_group.
  
  OptionGroup* option_group = static_cast<OptionGroup*>(data);
  if(option_group)
    return option_group->on_error(cppContext, cppGroup);
}

} //anonymous namespace


OptionGroup::OptionGroup(const Glib::ustring& name, const Glib::ustring& description, const Glib::ustring& help_description)
: gobject_( g_option_group_new(name.c_str(), description.c_str(), help_description.c_str(), this, 0 /* destroy_func */) )
{
  //Connect callbacks, so that derived classes can override the virtual methods:
  g_option_group_set_parse_hooks(gobj(), &g_callback_pre_parse, &g_callback_post_parse);
  g_option_group_set_error_hook(gobj(), &g_callback_error);
}

OptionGroup::OptionGroup(GOptionGroup* castitem, bool take_copy)
{
  if(take_copy)
  {
  }
  else
    gobject_ = castitem;
}

OptionGroup::~OptionGroup()
{
  g_option_group_free(gobj());
  gobject_ = 0;
}


bool OptionGroup::on_pre_parse(OptionContext& /* context */, OptionGroup& /* group */)
{
  return true;
}

bool OptionGroup::on_post_parse(OptionContext& /* context */, OptionGroup& /* group */)
{
  return true;
}

void OptionGroup::on_error(OptionContext& /* context */, OptionGroup& /* group */)
{
}

  


} // namespace Glib

