// -*- c++ -*-
/* $Id: iochannel.ccg,v 1.6 2006/10/04 12:04:09 murrayc Exp $ */

/* Copyright (C) 2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/exceptionhandler.h>
#include <glibmm/iochannel.h>
#include <glibmm/utility.h>
#include <glibmm/main.h>


namespace Glib
{


/**** GLib::IOChannel ******************************************************/


IOChannel::IOChannel(GIOChannel* gobject, bool take_copy)
:
  gobject_ (gobject)
{
  if(take_copy)
    g_io_channel_ref(gobject_);
}

IOChannel::~IOChannel()
{
  if(gobject_)
  {
    GIOChannel *const tmp_gobject = gobject_;
    gobject_ = 0;

    g_io_channel_unref(tmp_gobject);
  }
}

Glib::RefPtr<IOChannel> IOChannel::create_from_file(const std::string& filename, const std::string& mode)
{
  GError* gerror = 0;
  GIOChannel *const channel = g_io_channel_new_file(filename.c_str(), mode.c_str(), &gerror);

  if(gerror)
  {
    Glib::Error::throw_exception(gerror);
  }

  return Glib::wrap(channel, false);
}

Glib::RefPtr<IOChannel> IOChannel::create_from_fd(int fd)
{
  return Glib::wrap(g_io_channel_unix_new(fd), false);
}

#ifdef G_OS_WIN32

Glib::RefPtr<IOChannel> IOChannel::create_from_win32_fd(int fd)
{
  return Glib::wrap(g_io_channel_win32_new_fd(fd), false);
}

Glib::RefPtr<IOChannel> IOChannel::create_from_win32_socket(int socket)
{
  return Glib::wrap(g_io_channel_win32_new_socket(socket), false);
}

#endif /* G_OS_WIN32 */

IOStatus IOChannel::write(const Glib::ustring& str)
{
  gsize bytes_written = 0;
  return write(str.data(), str.bytes(), bytes_written);
}

IOStatus IOChannel::read_line(Glib::ustring& line)
{
  Glib::ScopedPtr<char> buf;
  GError* gerror = 0;
  gsize   bytes = 0;

  const GIOStatus status = g_io_channel_read_line(gobj(), buf.addr(), &bytes, 0, &gerror);

  if(gerror)
  {
    Glib::Error::throw_exception(gerror);
  }

  if(buf.get())
    line.assign(buf.get(), buf.get() + bytes);
  else
    line.erase();

  return (IOStatus) status;
}

IOStatus IOChannel::read_to_end(Glib::ustring& str)
{
  Glib::ScopedPtr<char> buf;
  GError* gerror = 0;
  gsize   bytes = 0;

  const GIOStatus status = g_io_channel_read_to_end(gobj(), buf.addr(), &bytes, &gerror);

  if(gerror)
  {
    Glib::Error::throw_exception(gerror);
  }

  if(buf.get())
    str.assign(buf.get(), buf.get() + bytes);
  else
    str.erase();

  return (IOStatus) status;
}

IOStatus IOChannel::read(Glib::ustring& str, gsize count)
{
  Glib::ScopedPtr<char> buf (g_new(char, count));
  GError* gerror = 0;
  gsize   bytes = 0;

  const GIOStatus status = g_io_channel_read_chars(gobj(), buf.get(), count, &bytes, &gerror);

 if(gerror)
  {
    Glib::Error::throw_exception(gerror);
  }

  if(buf.get())
    str.assign(buf.get(), buf.get() + bytes);
  else
    str.erase();

  return (IOStatus) status;
}

IOStatus IOChannel::set_encoding(const std::string& encoding)
{
  GError* gerror = 0;

  const GIOStatus status = g_io_channel_set_encoding(
      gobj(), (encoding.empty()) ? 0 : encoding.c_str(), &gerror);

  if(gerror)
  {
    Glib::Error::throw_exception(gerror);
  }

  return (IOStatus) status;
}

std::string IOChannel::get_encoding() const
{
  const char *const encoding = g_io_channel_get_encoding(gobject_);
  return (encoding) ? std::string(encoding) : std::string();
}

void IOChannel::set_line_term(const std::string& term)
{
  if(term.empty())
    g_io_channel_set_line_term(gobj(), 0, 0);
  else
    g_io_channel_set_line_term(gobj(), term.data(), term.size());
}

std::string IOChannel::get_line_term() const
{
  int len = 0;
  const char *const term = g_io_channel_get_line_term(gobject_, &len);

  return (term) ? std::string(term, len) : std::string();
}

Glib::RefPtr<IOSource> IOChannel::create_watch(IOCondition condition)
{
  // The corresponding unreference() takes place in the dtor
  // of the Glib::RefPtr<IOChannel> object below.
  reference();
  return IOSource::create(Glib::RefPtr<IOChannel>(this), condition);
}

void IOChannel::reference() const
{
  g_io_channel_ref(gobject_);
}

void IOChannel::unreference() const
{
  g_io_channel_unref(gobject_);
}

Glib::RefPtr<IOChannel> wrap(GIOChannel* gobject, bool take_copy)
{
  IOChannel* cpp_object = 0;

  if(gobject)
  {
    cpp_object = new IOChannel(gobject, take_copy);
    cpp_object->reference(); // the refcount is initially 0
  }

  return Glib::RefPtr<IOChannel>(cpp_object);
}


} // namespace Glib
